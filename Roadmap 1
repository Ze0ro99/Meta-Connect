cd ../frontend
npm install
npm start
===============√∑
cd backend
npm install
npm start
#################
unzip my_web3_app.zip
cd my_web3_app
@@@@@@@@@@@@@@@@@
ÿÆÿ∑ÿ© ÿ£ŸàŸÑŸäÿ© ŸÑÿ®ŸÜÿßÿ° ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ:
1. ÿßŸÑŸÖÿ™ÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© ŸàÿßŸÑŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©:
ÿØÿπŸÖ ÿßŸÑÿπŸÖŸÑÿßÿ™ ÿßŸÑÿ±ŸÇŸÖŸäÿ© (ŸÖÿ´ŸÑ Pi Network):

ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Pi Network ŸÑÿ™ŸÇÿØŸäŸÖ ÿßŸÑŸÖÿπÿßŸÖŸÑÿßÿ™ÿå Ÿàÿ™ÿ≠ŸÅŸäÿ≤ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÑÿ£ÿπŸÖÿßŸÑ ÿ±ŸÇŸÖŸäÿ©.
ÿØÿπŸÖ Ÿàÿ±ÿ®ÿ∑Ÿáÿß ÿ±ŸÇŸÖŸäŸãÿß ŸÖÿπ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ.
ŸÖŸÇÿ™ÿ±ÿ≠ÿßÿ™ ÿßŸÑŸÇŸàŸâ ÿßŸÑŸÖŸÜÿÆŸÅÿ∂ÿ© ÿßŸÑÿØÿÆŸÑ.
ŸÜÿ∏ÿßŸÖ ŸÖŸÑŸÅÿßÿ™ ÿ¥ÿÆÿµŸä Ÿäÿ¥ŸÖŸÑ:

ÿ™ÿ¥ÿ®Ÿá ŸÖŸÑŸÅÿßÿ™ ÿ™ŸàŸäÿ™ÿ±/ŸÅŸäÿ≥ÿ®ŸàŸÉ/ÿ•ŸÜÿ≥ÿ™ÿ¨ÿ±ÿßŸÖ ÿ®ÿ≠Ÿäÿ´ ŸäŸÖŸÉŸÜ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ®ÿßÿ™ ŸàŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ.
ÿ™ÿÆÿµŸäÿµ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑÿ¥ÿÆÿµŸäÿ©ÿå ÿØÿπŸÖ ÿßŸÑŸÜÿ¥ÿ± ŸÖÿ´ŸÑ ÿßŸÑŸÇÿµÿµ (ŸÖÿ´ŸÑ ÿ≥ŸÜÿßÿ® ÿ¥ÿßÿ™)ÿå ŸàÿßŸÑŸÖŸÜÿ¥Ÿàÿ±ÿßÿ™ (ŸÖÿ´ŸÑ ŸÅŸäÿ≥ÿ®ŸàŸÉ).
ŸÅŸäÿØŸäŸàŸáÿßÿ™ Ÿàÿ®ÿ´ ŸÖÿ®ÿßÿ¥ÿ±:

ŸÜÿ™Ÿäÿ¨ÿ© ŸÖÿ¥ÿßÿ®Ÿáÿ© ŸÑŸÄ ŸäŸàÿ™ŸäŸàÿ®/ÿ™ŸäŸÉ ÿ™ŸàŸÉ ŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ÿßŸÑŸÅŸäÿØŸäŸà ŸàÿßŸÑÿ®ÿ´ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±.
ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿ™ŸÇÿØŸäŸÖ ÿßŸÑÿØÿπŸÖ ŸÑÿµŸÜÿßÿπ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿπŸÖŸÑÿßÿ™ ÿßŸÑÿ±ŸÇŸÖŸäÿ©.
ÿØÿπŸÖ ÿßŸÑŸÑÿ∫ÿßÿ™ ÿßŸÑÿπÿßŸÑŸÖŸäÿ©:

Ÿàÿßÿ¨Ÿáÿ© ÿ≥ŸáŸÑÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ™ÿØÿπŸÖ ÿ¨ŸÖŸäÿπ ŸÑÿ∫ÿßÿ™ ÿßŸÑÿπÿßŸÑŸÖ ŸÖŸÜ ÿÆŸÑÿßŸÑ ÿ™Ÿàÿ∑ŸäŸÜ (Localization) ÿØŸäŸÜÿßŸÖŸäŸÉŸäŸãÿß.
ŸÑŸÑÿØÿπŸàÿßÿ™ ŸàÿßŸÑÿ¨Ÿàÿßÿ¶ÿ≤:

ŸÜÿ∏ÿßŸÖ ŸäŸÉÿßŸÅÿ¶ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿπŸÜÿØ ÿØÿπŸàÿ© ÿßŸÑÿ£ÿµÿØŸÇÿßÿ° ÿ•ŸÑŸâ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ.
Ÿàÿ∂ÿπŸäÿßÿ™ Ÿàÿßÿ¨Ÿáÿ© ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿ™ÿÆÿµŸäÿµ:

ÿßŸÑŸàÿ∂ÿπ ÿßŸÑÿ∫ÿßŸÖŸÇ ŸàÿßŸÑÿ•ÿ∂ÿßÿ°ÿ©ÿå Ÿàÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ£ŸÑŸàÿßŸÜ ÿßŸÑÿ≠ÿ±ÿ©.
ÿØÿπŸÖ ŸÉÿßŸÖŸÑ ŸÑŸÑŸÄ Metaverse ŸàNFTs:

Ÿäÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ ŸÖŸäÿ™ÿßŸÅŸäÿ±ÿ≥ ŸÑŸäÿ≥ŸÖÿ≠ ÿ®ÿ™ÿ¨ÿßÿ±ÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©.
ÿØÿπŸÖ NFTs ŸÑÿ•ŸÜÿ¥ÿßÿ° Ÿàÿ¥ÿ±ÿßÿ° ÿßŸÑÿ£ÿµŸàŸÑ ÿßŸÑÿ±ŸÇŸÖŸäÿ©.
ÿßŸÑÿ™ÿ≠ÿØŸäÿØÿßÿ™ ŸàÿßŸÑÿ£ÿØŸàÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿ©:
ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ£ŸÖÿßŸÖŸäÿ© (Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ):

React.js ÿ£Ÿà Next.js ŸÑŸàÿßÿ¨Ÿáÿ© ÿ™ŸÅÿßÿπŸÑŸäÿ© ŸÖÿ¨ÿßŸÜŸäÿ©.
TailwindCSS ŸÑÿ™ÿÆÿµŸäÿµ ÿßŸÑÿ™ÿµŸÖŸäŸÖ ŸàÿßŸÑÿ£ŸÑŸàÿßŸÜ ÿ®ÿ≥ŸáŸàŸÑÿ©.
ÿßŸÑÿÆŸÑŸÅŸäÿ© (Backend):

Node.js ÿ£Ÿà Express.js ŸäŸÜÿ¥ÿ¶ÿßŸÜ Ÿàÿßÿ¨Ÿáÿ© ÿ®ÿ±ŸÖÿ¨ÿ© ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇÿßÿ™ ÿ®ÿ≥ÿ±ÿπÿ©.
ŸÇŸàÿßÿπÿØ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ®ÿ™ŸÉÿ±ÿ© ŸÅŸä MongoDB ÿ£Ÿà PostgreSQL .
ÿ™ŸÉÿßŸÖŸÑ ÿßŸÑÿ®ŸÑŸàŸÉÿ¥ŸäŸÜ (ÿßŸÑÿ®ŸÑŸàŸÉ ÿ™ÿ¥ŸäŸÜ):

Pi Network SDK ÿ™ŸÉŸÜŸàŸÑŸàÿ¨Ÿäÿß ÿßŸÑÿ™ÿ¨ÿßÿ±ÿ© ÿßŸÑÿ±ŸÇŸÖŸäÿ©.
MetaMask ÿ£Ÿà WalletConnect ÿßÿ®ÿ™ŸÉÿßÿ±ÿßÿ™ ŸÖÿ®ÿ™ŸÉÿ±ÿ©.
ÿßŸÑÿ®ÿ´ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± ŸÑŸÑŸÅŸäÿØŸäŸà:

WebRTC ŸÑŸÑÿ®ÿ´ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±.
AWS S3 ÿ£Ÿà Cloudinary ŸÑŸÖÿ≠ÿ®Ÿä ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™.
ÿßŸÑÿ™Ÿàÿ∑ŸäŸÜ (ÿßŸÑŸÑÿ∫ÿßÿ™):

i18next ÿ£Ÿà React-intl ŸÑÿØÿπŸÖ ŸÑÿ∫ÿßÿ™ ŸÖÿ™ÿπÿØÿØÿ©.
ŸáŸäŸÉŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ (ÿßŸÑÿπŸÖÿßÿ±ÿ©):
ÿ•ÿ≥ ÿ•ÿ≥ ÿ•ÿ≥

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
üìÇ Root Project
‚îÇ
‚îú‚îÄ‚îÄ üìÇ frontend  (Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ React/Next.js)
‚îÇ   ‚îú‚îÄ‚îÄ pages
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îî‚îÄ‚îÄ styles
‚îÇ
‚îú‚îÄ‚îÄ üìÇ backend  (ÿßŸÑÿÆŸÑŸÅŸäÿ© Node.js/Express.js)
‚îÇ   ‚îú‚îÄ‚îÄ controllers
‚îÇ   ‚îú‚îÄ‚îÄ models
‚îÇ   ‚îú‚îÄ‚îÄ routes
‚îÇ   ‚îî‚îÄ‚îÄ config
‚îÇ
‚îú‚îÄ‚îÄ üìÇ blockchain  (ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ Pi Network)
‚îÇ   ‚îú‚îÄ‚îÄ walletIntegration.js
‚îÇ   ‚îî‚îÄ‚îÄ transactions.js
‚îÇ
‚îî‚îÄ‚îÄ üìÇ localization  (ÿØÿπŸÖ ÿßŸÑŸÑÿ∫ÿßÿ™)
    ‚îú‚îÄ‚îÄ ar.json
    ‚îú‚îÄ‚îÄ en.json
    ‚îî‚îÄ‚îÄ other_languages.json
ÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ© - ÿ±ŸÖÿ≤ ÿßŸÑÿ®ÿØÿ¶Ÿä:
1. ÿ•ÿπÿØÿßÿØ ÿ¥ÿ®ŸÉÿ© ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© Pi:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// blockchain/walletIntegration.js
const connectPiWallet = async () => {
  try {
    const wallet = await window.pi.connectWallet();
    console.log('Wallet connected:', wallet);
    return wallet;
  } catch (error) {
    console.error('Failed to connect wallet:', error);
  }
};
2. API ŸÑÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// backend/controllers/userController.js
const User = require('../models/userModel');

// ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ® ÿ¨ÿØŸäÿØ
const createUser = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    const newUser = await User.create({ username, email, password });
    res.status(201).json(newUser);
  } catch (error) {
    res.status(500).json({ error: 'Error creating user' });
  }
};

module.exports = { createUser };
3. Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ React:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/Register.js
import { useState } from 'react';
import axios from 'axios';

export default function Register() {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await axios.post('/api/register', { username, email, password });
      alert('User registered successfully!');
    } catch (error) {
      console.error('Registration failed:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="text" 
        placeholder="Username" 
        value={username} 
        onChange={(e) => setUsername(e.target.value)} 
      />
      <input 
        type="email" 
        placeholder="Email" 
        value={email} 
        onChange={(e) => setEmail(e.target.value)} 
      />
      <input 
        type="password" 
        placeholder="Password" 
        value={password} 
        onChange={(e) => setPassword(e.target.value)} 
      />
      <button type="submit">Register</button>
    </form>
  );
}
4. ÿßŸÑÿ®ÿ´ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ WebRTC:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/LiveStream.js
import { useRef } from 'react';

export default function LiveStream() {
  const videoRef = useRef();

  const startStream = async () => {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    videoRef.current.srcObject = stream;
  };

  return (
    <div>
      <video ref={videoRef} autoPlay playsInline></video>
      <button onClick={startStream}>Start Stream</button>
    </div>
  );
}
ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ™ÿ∑ŸàŸäÿ± ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™:

ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸÉÿßŸÅÿ¢ÿ™ ÿπŸÜÿØ ÿØÿπŸàÿ© ÿßŸÑÿ£ÿµÿØŸÇÿßÿ°.
ŸÇÿßÿ®ŸÑÿ© ŸÑÿ™ÿµŸÖŸäŸÖ Ÿàÿßÿ¨Ÿáÿ© ŸÑŸÑÿ™ÿÆÿµŸäÿµ:

ÿ•ÿ∂ÿßŸÅÿ© ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä ŸÑÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ£ŸÑŸàÿßŸÜ.
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿßÿ≥ÿ™ŸÉŸÖÿßŸÑ ÿ®ŸÜÿßÿ° Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ŸÖŸäÿ≤ÿßÿ™ ÿ£ÿÆÿ±Ÿâ ŸÖÿ´ŸÑ ÿßŸÑŸÇÿµÿµ ÿ£Ÿà ÿßŸÑŸÅŸäÿØŸäŸàÿü
ÿ®. ŸáŸÑ ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿßŸÑŸÖŸàÿßŸÅŸÇÿ© ÿπŸÑŸâ ÿßŸÑÿßÿÆÿ™ŸÑÿßŸÅ ÿßŸÑÿ¢ÿÆÿ± ŸÖŸÜ Pi Networkÿü





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ÿ¨ŸÖŸäŸÑ! ŸàŸÑŸÖ ŸÜŸÉŸÖŸÑ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÖŸäÿ≤ÿßÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸäÿ© ŸÖÿ´ŸÑ ÿßŸÑŸÇÿµÿµ (ÿßŸÑŸÇÿµÿµ) ŸàŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ÿå ÿ®ÿßŸÑÿ•ÿ∂ÿßŸÅÿ© ÿ•ŸÑŸâ ŸÜÿ∏ÿßŸÖ ÿØÿπŸàÿßÿ™ ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™ . ŸÉŸÖÿßÿπŸÖŸÑ ÿπŸÑŸâ ÿßŸÑÿ£ŸàŸÇÿßÿ™ ÿØÿπŸÖ ÿßŸÑÿ≠Ÿäÿ≤ ÿßŸÑŸÖÿ≥ÿ™ŸÖÿ± Pi Network. ÿ≥ÿ£ÿ™ÿ£ŸÉÿØ ÿ£Ÿäÿ∂Ÿãÿß ŸÖŸÜ ÿ£ŸÜ Ÿàÿßÿ¨Ÿáÿ© ÿ≥ŸáŸÑÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖÿå ŸÖÿπ ÿ•ŸÖŸÉÿßŸÜŸäÿ© ÿ™ÿÆÿµŸäÿµ ÿßŸÑÿ£ŸÑŸàÿßŸÜ ŸàÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä.

ÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿ¨ÿØŸäÿØÿ©:
ÿßŸÑŸÇÿµÿµ (ÿßŸÑŸÇÿµÿµ) ŸÖÿ´ŸÑ ÿ≥ŸÜÿßÿ® ÿ¥ÿßÿ™:

ŸäŸÖŸÉŸÜ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÜÿ¥ÿ± ÿßŸÑŸÇÿµÿµ ÿ®ÿπÿØ 24 ÿ≥ÿßÿπÿ©.
ÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ§ŸÇÿ™ÿ©.
ŸÜÿ∏ÿßŸÖ ÿßŸÑÿØÿπŸàÿßÿ™ ŸàÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™:

ŸäŸÖŸÜÿ≠ ŸÖŸÉÿßŸÅÿ¢ÿ™ ÿπŸÜÿØ ÿØÿπŸàÿ© ÿßŸÑÿ£ÿµÿØŸÇÿßÿ°.
ÿ™ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ ÿßŸÑÿπŸÖŸÑÿßÿ™ ÿßŸÑÿ±ŸÇŸÖŸäÿ© (Pi Network).
ÿ•ÿ∂ÿßŸÅÿ© ÿØÿπŸÖ ÿßŸÑÿßŸÑÿ™ÿ≤ÿßŸÖÿßÿ™:

MetaMask Ÿà WalletConnect Beam Pi Network.
1. ŸÜÿ¥ÿ± ÿßŸÑÿ£ÿÆÿ®ÿßÿ± (ÿßŸÑŸÇÿµÿµ):
ÿßŸÑÿÆŸÑŸÅŸäÿ© - API ŸÑŸÑŸÇÿµÿµ:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// backend/controllers/storyController.js
const Story = require('../models/storyModel');

// ÿ•ÿ∂ÿßŸÅÿ© ŸÇÿµÿ© ÿ¨ÿØŸäÿØÿ©
const addStory = async (req, res) => {
  try {
    const { userId, content, image } = req.body;
    const newStory = await Story.create({ userId, content, image, expiresAt: Date.now() + 86400000 });
    res.status(201).json(newStory);
  } catch (error) {
    res.status(500).json({ error: 'Error adding story' });
  }
};

// ÿ¨ŸÑÿ® ÿßŸÑŸÇÿµÿµ ÿßŸÑŸÜÿ¥ÿ∑ÿ©
const getActiveStories = async (req, res) => {
  try {
    const stories = await Story.find({ expiresAt: { $gt: Date.now() } });
    res.status(200).json(stories);
  } catch (error) {
    res.status(500).json({ error: 'Error fetching stories' });
  }
};

module.exports = { addStory, getActiveStories };
ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ£ŸÖÿßŸÖŸäÿ© - ÿ®ÿ±ŸÖÿ¨ÿ© ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÉÿ™ÿ®:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/Stories.js
import { useEffect, useState } from 'react';
import axios from 'axios';

export default function Stories() {
  const [stories, setStories] = useState([]);
  const [content, setContent] = useState('');

  useEffect(() => {
    fetchStories();
  }, []);

  const fetchStories = async () => {
    const response = await axios.get('/api/stories');
    setStories(response.data);
  };

  const handleAddStory = async () => {
    await axios.post('/api/stories', { content });
    setContent('');
    fetchStories();
  };

  return (
    <div>
      <input 
        type="text" 
        placeholder="Add your story" 
        value={content} 
        onChange={(e) => setContent(e.target.value)} 
      />
      <button onClick={handleAddStory}>Post Story</button>

      <div>
        {stories.map(story => (
          <div key={story._id}>
            <p>{story.content}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
2. ŸÜÿ∏ÿßŸÖ ÿØÿπŸàÿßÿ™ ÿßŸÑÿ£ÿµÿØŸÇÿßÿ° ŸàÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™:
ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿÆŸÑŸÅŸäÿ© - API ŸÑÿØÿπŸàÿßÿ™ ÿßŸÑÿ£ÿµÿØŸÇÿßÿ°:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// backend/controllers/inviteController.js
const User = require('../models/userModel');

// ÿ•ÿ±ÿ≥ÿßŸÑ ÿØÿπŸàÿ© ÿµÿØŸäŸÇ
const inviteFriend = async (req, res) => {
  try {
    const { inviterId, inviteeEmail } = req.body;

    // ŸÖŸÜÿ∑ŸÇ ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸÉÿßŸÅÿ¢ÿ™ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const inviter = await User.findById(inviterId);
    inviter.rewards += 10;  // ÿ•ÿ∂ÿßŸÅÿ© 10 ÿπŸÖŸÑÿßÿ™ ÿ±ŸÇŸÖŸäÿ© ŸÉŸÖŸÉÿßŸÅÿ£ÿ©
    await inviter.save();

    res.status(200).json({ message: 'Invitation sent successfully!' });
  } catch (error) {
    res.status(500).json({ error: 'Error sending invitation' });
  }
};

module.exports = { inviteFriend };
Frontend - Ÿàÿßÿ¨Ÿáÿ© ÿØÿπŸàÿßÿ™ ÿßŸÑÿ£ÿµÿØŸÇÿßÿ°:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/Invite.js
import { useState } from 'react';
import axios from 'axios';

export default function Invite() {
  const [email, setEmail] = useState('');

  const handleInvite = async () => {
    try {
      await axios.post('/api/invite', { inviteeEmail: email });
      alert('Invitation sent successfully!');
    } catch (error) {
      console.error('Invitation failed:', error);
    }
  };

  return (
    <div>
      <input 
        type="email" 
        placeholder="Friend's email" 
        value={email} 
        onChange={(e) => setEmail(e.target.value)} 
      />
      <button onClick={handleInvite}>Invite Friend</button>
    </div>
  );
}
3. ÿßŸÑÿßŸÑÿ™ÿ≤ÿßŸÖ ÿ®ÿßŸÑÿ≥ŸÑÿßŸÖÿ©:
ÿßŸÑÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ MetaMask:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// blockchain/metaMaskIntegration.js
const connectMetaMask = async () => {
  if (typeof window.ethereum !== 'undefined') {
    try {
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      console.log('Connected account:', accounts[0]);
      return accounts[0];
    } catch (error) {
      console.error('MetaMask connection failed:', error);
    }
  } else {
    alert('MetaMask not installed!');
  }
};
Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ®ŸÜŸÉ ÿßÿÆÿ™Ÿäÿßÿ±:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/WalletSelector.js
import { useState } from 'react';
import { connectMetaMask } from '../blockchain/metaMaskIntegration';
import { connectPiWallet } from '../blockchain/walletIntegration';

export default function WalletSelector() {
  const [wallet, setWallet] = useState(null);

  const handleConnectMetaMask = async () => {
    const account = await connectMetaMask();
    setWallet(account);
  };

  const handleConnectPiWallet = async () => {
    const wallet = await connectPiWallet();
    setWallet(wallet);
  };

  return (
    <div>
      <button onClick={handleConnectMetaMask}>Connect MetaMask</button>
      <button onClick={handleConnectPiWallet}>Connect Pi Wallet</button>

      {wallet && <p>Connected: {wallet}</p>}
    </div>
  );
}
4. ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä Ÿàÿ™ÿÆÿµŸäÿµ ÿßŸÑÿ£ŸÑŸàÿßŸÜ:
ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ£ŸÖÿßŸÖŸäÿ© - ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ£ŸÑŸàÿßŸÜ:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/ThemeSwitcher.js
import { useState } from 'react';

export default function ThemeSwitcher() {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);
    document.body.setAttribute('data-theme', newTheme);
  };

  return (
    <button onClick={toggleTheme}>
      Switch to {theme === 'light' ? 'Dark' : 'Light'} Mode
    </button>
  );
}
ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:
ÿ•ÿ∂ÿßŸÅÿ© ÿ∫ÿ±ÿ∂ NFTs ŸÑÿØÿπŸÖ ÿßŸÑÿ£ÿµŸàŸÑ ÿßŸÑÿ±ŸÇŸÖŸäÿ©.
ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ¥ÿßÿ¶ÿπ ÿ£Ÿä ÿ£ÿÆÿ∑ÿßÿ°.
ÿ™ÿ≠ÿ≥ŸäŸÜ ÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (UX) ŸÑÿ™ÿ≥ŸáŸäŸÑ ÿßŸÑÿ™ŸÅÿßÿπŸÑ.
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿØŸÖÿ¨ NFTs ÿ£Ÿà ÿßŸÑÿ£ÿµŸàŸÑ ÿßŸÑÿ±ŸÇŸÖŸäÿ© ÿßŸÑÿ¢ŸÜÿü
ÿ®. ŸáŸÑ ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ŸÑÿ∫ÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ÿ£Ÿà ÿ™ÿ≥ŸáŸäŸÑÿßÿ™ ÿπŸÑŸâ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿØÿπŸàÿßÿ™ÿü





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ŸÖŸÖÿ™ÿßÿ≤! Ÿàÿ£ÿÆŸäÿ±Ÿãÿßÿå ŸáŸÜÿßŸÉ ŸÖŸäÿ≤ÿ© ÿ¨ÿØŸäÿØÿ© ÿ™ÿ™ŸÖÿ´ŸÑ ŸÅŸä ÿØÿπŸÖ ÿ£ÿµŸàŸÑ NFTs ÿßŸÑÿ±ŸÇŸÖŸäÿ© ŸÑÿ™ÿ≥ÿßÿπÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿπŸÑŸâ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿπÿ±ÿ∂ÿå Ÿàÿ¥ÿ±ÿßÿ° NFTs. ÿ≥ÿ£ŸÇŸàŸÖ ÿ®ÿØŸÖÿ¨ Ÿáÿ∞Ÿá ÿßŸÑÿ£ÿÆŸäÿ±ÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ERC-721 ÿå ŸàŸáŸà ŸÜŸÖŸàÿ∞ÿ¨ ÿ¥ÿßÿ¶ÿπ ŸÅŸä ÿ™ÿ∑ŸàŸäÿ± ÿßŸÑŸÄ NFTs. Ÿàÿ≥ÿ™ÿ≠ÿ™ŸàŸä ÿ£Ÿäÿ∂Ÿãÿß ÿπŸÑŸâ Ÿàÿßÿ¨Ÿáÿ© ÿ™ÿ≥ÿßÿπÿØ ŸÅŸä ÿπÿ±ÿ∂ Ÿáÿ∞Ÿá ÿßŸÑÿ£ÿµŸàŸÑÿå ŸÖŸÖÿß ŸäŸàŸÅÿ± ÿ™ÿ¨ÿ±ÿ®ÿ© ÿ≥ŸÑÿ≥ÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÅŸä ÿßŸÑÿ®Ÿäÿπ Ÿàÿ¥ÿ±ÿßÿ° ÿßŸÑŸÖÿ≠ÿ™ŸàŸäÿßÿ™ ÿ±ŸÇŸÖŸäŸãÿß.

ÿÆÿ∑ÿ© ÿ™ÿ∑ŸàŸäÿ± NFTs ŸÅŸä ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ:
ÿ•ŸÜÿ¥ÿßÿ° ÿπŸÇŸàÿØ ÿ∞ŸÉŸäÿ© ŸÑŸÑŸÄ NFTs ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Solidity.
ÿØŸÖÿ¨ ÿßŸÑÿπŸÇŸàÿØ ÿßŸÑÿ∞ŸÉŸäÿ© ŸÖÿπ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿπÿ®ÿ± Web3.js ÿ£Ÿà Ethers.js.
ÿ•ÿ∂ÿßŸÅÿ© Ÿàÿßÿ¨Ÿáÿ© ŸÑÿ™ÿ≠ŸÖŸäŸÑ NFTs Ÿàÿ¥ÿ±ÿßÿ¶Ÿáÿß.
ÿØÿπŸÖ ÿ®Ÿäÿπ NFTs ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿπŸÖŸÑÿ© Pi Network ÿ£Ÿà ÿπÿ®ÿ± MetaMask.
1. ÿπŸÇÿØ ÿ∞ŸÉŸä ŸÑŸÑŸÄ NFTs ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Solidity
ÿµŸÑÿßÿ®ÿ©

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// contracts/NFTContract.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract NFTContract is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721("MyNFT", "MNFT") {}

    function mintNFT(address recipient, string memory tokenURI) public returns (uint256) {
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(recipient, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }
}
2. ŸÜÿ¥ÿ± ÿßŸÑÿπŸÇÿØ ÿßŸÑÿ∞ŸÉŸä ÿπŸÑŸâ ÿ¥ÿ®ŸÉÿ© ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ± (Testnet):
ŸÇŸÖ ÿ®ÿ™ÿ¨ÿ±ÿ®ÿ© MetaMask Ÿàÿ±ÿ®ÿ∑Ÿáÿß ÿ®ÿ¥ÿ®ŸÉÿ© ŸÖÿ´ŸÑ Rinkeby .
ÿßÿ≥ÿ™ÿÆÿØŸÖ Remix IDE ÿ£Ÿà Hardhat ÿßŸÑÿ¥ÿ®ÿßÿ® .
ÿ®ÿπÿØ ÿßŸÑŸÜÿ¥ÿ±ÿå ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ∞ŸÉŸä ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá ŸÅŸä ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ.
3. ÿ™ŸÉÿßŸÖŸÑ ÿßŸÑÿπŸÇÿØ ŸÖÿπ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ethers.js:
ÿ•ÿπÿØÿßÿØ Web3 ŸÑŸÑÿ™ŸÅÿßÿπŸÑ ŸÖÿπ ÿßŸÑÿπŸÇÿØ:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// blockchain/nftIntegration.js
import { ethers } from 'ethers';
import NFTContractABI from './NFTContractABI.json'; // ABI ÿßŸÑÿÆÿßÿµ ÿ®ÿßŸÑÿπŸÇÿØ ÿßŸÑÿ∞ŸÉŸä

const CONTRACT_ADDRESS = 'YOUR_CONTRACT_ADDRESS_HERE'; // ÿπŸÜŸàÿßŸÜ ÿßŸÑÿπŸÇÿØ

export const mintNFT = async (recipient, tokenURI) => {
  try {
    const { ethereum } = window;
    if (!ethereum) throw new Error('MetaMask is not installed');

    const provider = new ethers.providers.Web3Provider(ethereum);
    const signer = provider.getSigner();
    const nftContract = new ethers.Contract(CONTRACT_ADDRESS, NFTContractABI, signer);

    const tx = await nftContract.mintNFT(recipient, tokenURI);
    await tx.wait();

    console.log('NFT minted successfully!', tx);
  } catch (error) {
    console.error('Error minting NFT:', error);
  }
};
4. ÿ®ÿ±ŸÖÿ¨ÿ© ŸÇÿ±ÿßÿ°ÿ© NFTs ŸÅŸä ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ:
Ÿàÿßÿ¨Ÿáÿ© ÿ±ŸÅÿπ NFTs:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/MintNFT.js
import { useState } from 'react';
import { mintNFT } from '../blockchain/nftIntegration';

export default function MintNFT() {
  const [recipient, setRecipient] = useState('');
  const [tokenURI, setTokenURI] = useState('');

  const handleMint = async () => {
    try {
      await mintNFT(recipient, tokenURI);
      alert('NFT minted successfully!');
    } catch (error) {
      console.error('Minting failed:', error);
    }
  };

  return (
    <div>
      <input 
        type="text" 
        placeholder="Recipient Address" 
        value={recipient} 
        onChange={(e) => setRecipient(e.target.value)} 
      />
      <input 
        type="text" 
        placeholder="Token URI (Metadata URL)" 
        value={tokenURI} 
        onChange={(e) => setTokenURI(e.target.value)} 
      />
      <button onClick={handleMint}>Mint NFT</button>
    </div>
  );
}
5. Ÿàÿßÿ¨Ÿáÿ© ÿπÿ±ÿ∂ Ÿàÿ¥ÿ±ÿßÿ° NFTs:
Ÿàÿßÿ¨Ÿáÿ© ÿπÿ±ÿ∂ NFTs:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/NFTMarketplace.js
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import NFTContractABI from '../blockchain/NFTContractABI.json';

const CONTRACT_ADDRESS = 'YOUR_CONTRACT_ADDRESS_HERE';

export default function NFTMarketplace() {
  const [nfts, setNFTs] = useState([]);

  useEffect(() => {
    fetchNFTs();
  }, []);

  const fetchNFTs = async () => {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const contract = new ethers.Contract(CONTRACT_ADDRESS, NFTContractABI, provider);
    
    // ŸÅÿ±ÿ∂Ÿãÿß ÿ£ŸÜ ÿßŸÑÿπŸÇÿØ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿØÿßŸÑÿ© getAllNFTs() ŸÑÿ¨ŸÑÿ® ÿ¨ŸÖŸäÿπ NFTs
    const allNFTs = await contract.getAllNFTs();
    setNFTs(allNFTs);
  };

  return (
    <div>
      {nfts.map((nft, index) => (
        <div key={index}>
          <p>NFT ID: {nft.id}</p>
          <p>Owner: {nft.owner}</p>
          <img src={nft.tokenURI} alt={`NFT ${nft.id}`} />
        </div>
      ))}
    </div>
  );
}
6. ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:
ÿ•ÿ∂ÿßŸÅÿ© ÿØÿπŸÖ ÿßŸÑÿØŸÅÿπ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Pi Network ŸÅŸä ÿ≥ŸàŸÇ NFTs.
ÿ™ÿ™Ÿäÿ≠ ÿ≥ŸáŸàŸÑÿ© ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ≥ŸÑÿ≥ÿ©.
ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿµÿßÿØŸÇÿ© ÿ≤Ÿàÿßÿ¨ NFTs ÿπÿ®ÿ± ÿ™ÿ≠ŸäŸäÿØÿßÿ™ ŸÅŸÇÿ∑.
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸäÿ≤ÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÑÿ≥ŸàŸÇ NFTsÿå ŸÖÿ´ŸÑ ÿßŸÑŸÖÿ≤ÿßŸäÿØÿßÿ™ÿü
ÿ®. ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿØŸÖÿ¨ ŸÜÿ∏ÿßŸÖ ÿØŸÅÿπ ŸÖÿ¥ÿ™ÿ±ŸÉ ÿ®ŸäŸÜ Pi ŸàMetaMaskÿü





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ÿ±ÿßÿ¶ÿπ! ÿ≥ÿ£ŸÇŸàŸÖ ÿßŸÑÿ¢ŸÜ ÿ®ÿ•ÿ∂ÿßŸÅÿ© ŸÖŸäÿ≤ÿßÿ™ ÿ≥ŸàŸÇ ÿßŸÑŸÖŸÖŸäÿ≤ÿßÿ™ ÿπŸÑŸâ NFTs ŸÅŸäÿå ÿ•ŸÑŸâ ÿ¨ÿßŸÜÿ® ÿØŸÖÿ¨ ŸÜÿ∏ÿßŸÖ ÿßŸÑÿØŸÅÿπ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ®ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿØŸÅÿπ ÿ•ŸÖÿß ŸÖŸÜ ÿÆŸÑÿßŸÑ Wallet Pi Network ÿ£Ÿà MetaMask . ÿ≥ÿ£ÿ≠ÿ±ÿµ ÿ£Ÿäÿ∂Ÿãÿß ÿπŸÑŸâ ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑÿ¥ÿ±ÿßÿ° ŸÖÿ±ŸÜÿ©ÿå ÿ®ÿ≠Ÿäÿ´ Ÿäÿ®ÿØÿ£ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ÿßÿÆÿ™Ÿäÿßÿ± Ÿàÿ≥ŸäŸÑÿ© ÿßŸÑÿØŸÅÿπ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ© ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÖŸÜ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ.

ÿßŸÑÿÆÿ∑ÿ© ÿßŸÑÿ™ÿ∑ŸàŸäÿ±Ÿäÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ© :
ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ≤ŸäÿßÿØÿßÿ™ ÿπŸÑŸâ NFTs:
ÿ≥ŸÖÿ≠ ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ®ÿßŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿπŸÑŸâ NFTsÿå ŸÖÿπ ÿ£ÿπŸÑŸâ ŸÖŸäÿ≤ÿ© ÿ™ŸÅŸàÿ≤.
ÿØŸÖÿ¨ ŸÜÿ∏ÿßŸÖ ÿØŸÅÿπ ŸÖÿ¥ÿ™ÿ±ŸÉ:
ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿ®ÿßŸÑÿØŸÅÿπ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Pi Network ÿ£Ÿà MetaMask .
Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿØÿπŸàÿ© ŸÑŸÑŸÖÿ≤ÿßŸäÿØÿ© ŸàÿßŸÑÿØŸÅÿπ.
1. ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ÿ∫ÿßŸÜŸä ÿßŸÑÿ∞ŸÉŸäÿ© ŸÑŸÖŸÇÿßŸàŸÖÿ© ÿßŸÑŸÖÿ≤ÿßŸäÿØÿßÿ™
ÿπŸÇÿØ ÿ∞ŸÉŸä ÿ¨ÿØŸäÿØ ŸäÿØÿπŸÖ ÿßŸÑŸÖÿ≤ÿßŸäÿØÿ©:
ÿµŸÑÿßÿ®ÿ©

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// contracts/AuctionNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract AuctionNFT is ERC721 {
    struct Auction {
        address highestBidder;
        uint256 highestBid;
        bool active;
    }

    mapping(uint256 => Auction) public auctions;

    constructor() ERC721("AuctionNFT", "ANFT") {}

    function mintNFT(address recipient, uint256 tokenId) public {
        _mint(recipient, tokenId);
    }

    function startAuction(uint256 tokenId) public {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        auctions[tokenId] = Auction(address(0), 0, true);
    }

    function placeBid(uint256 tokenId) public payable {
        Auction storage auction = auctions[tokenId];
        require(auction.active, "Auction not active");
        require(msg.value > auction.highestBid, "Bid too low");

        // ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ£ŸÖŸàÿßŸÑ ŸÑŸÑŸÖÿ≤ÿßŸäÿØ ÿßŸÑÿ≥ÿßÿ®ŸÇ
        if (auction.highestBidder != address(0)) {
            payable(auction.highestBidder).transfer(auction.highestBid);
        }

        auction.highestBid = msg.value;
        auction.highestBidder = msg.sender;
    }

    function endAuction(uint256 tokenId) public {
        Auction storage auction = auctions[tokenId];
        require(ownerOf(tokenId) == msg.sender, "Not the owner");

        auction.active = false;
        _transfer(ownerOf(tokenId), auction.highestBidder, tokenId);
        payable(msg.sender).transfer(auction.highestBid);
    }
}
2. Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ© ÿπŸÑŸâ NFTs
ÿµŸÅÿ≠ÿ© ÿßŸÑÿ≤ŸäÿßÿØÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ React:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/Auction.js
import { useState } from 'react';
import { ethers } from 'ethers';
import NFTContractABI from '../blockchain/NFTContractABI.json';

const CONTRACT_ADDRESS = 'YOUR_CONTRACT_ADDRESS_HERE';

export default function Auction() {
  const [tokenId, setTokenId] = useState('');
  const [bidAmount, setBidAmount] = useState('');
  
  const placeBid = async () => {
    try {
      const { ethereum } = window;
      if (!ethereum) throw new Error('MetaMask is not installed');

      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(CONTRACT_ADDRESS, NFTContractABI, signer);

      const tx = await contract.placeBid(tokenId, { value: ethers.utils.parseEther(bidAmount) });
      await tx.wait();

      alert('Bid placed successfully!');
    } catch (error) {
      console.error('Error placing bid:', error);
    }
  };

  return (
    <div>
      <input 
        type="text" 
        placeholder="Token ID" 
        value={tokenId} 
        onChange={(e) => setTokenId(e.target.value)} 
      />
      <input 
        type="text" 
        placeholder="Bid Amount (ETH)" 
        value={bidAmount} 
        onChange={(e) => setBidAmount(e.target.value)} 
      />
      <button onClick={placeBid}>Place Bid</button>
    </div>
  );
}
3. ÿ•ÿ∂ÿßŸÅÿ© ŸÜÿ∏ÿßŸÖ ÿßŸÑÿØŸÅÿπ ÿßŸÑŸÖÿ¥ÿ™ÿ±ŸÉ (Pi Network ŸàMetaMask)
Ÿàÿßÿ¨Ÿáÿ© ÿßÿÆÿ™Ÿäÿßÿ± Ÿàÿ≥ŸäŸÑÿ© ÿßŸÑÿØŸÅÿπ:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/PaymentSelector.js
import { useState } from 'react';
import { connectMetaMask } from '../blockchain/metaMaskIntegration';
import { connectPiWallet } from '../blockchain/walletIntegration';

export default function PaymentSelector({ onPaymentComplete }) {
  const [paymentMethod, setPaymentMethod] = useState('MetaMask');

  const handlePayment = async () => {
    if (paymentMethod === 'MetaMask') {
      const account = await connectMetaMask();
      alert(`Paid with MetaMask: ${account}`);
    } else if (paymentMethod === 'Pi Network') {
      const wallet = await connectPiWallet();
      alert(`Paid with Pi Wallet: ${wallet}`);
    }
    onPaymentComplete();
  };

  return (
    <div>
      <select 
        value={paymentMethod} 
        onChange={(e) => setPaymentMethod(e.target.value)}
      >
        <option value="MetaMask">MetaMask</option>
        <option value="Pi Network">Pi Network</option>
      </select>
      <button onClick={handlePayment}>Pay Now</button>
    </div>
  );
}
4. ÿπÿ±ÿ∂ NFTs ŸàÿßŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿπŸÑŸäŸáÿß:
Ÿàÿßÿ¨Ÿáÿ© ÿ≥ŸàŸÇ NFTs:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/NFTMarketplace.js
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import NFTContractABI from '../blockchain/NFTContractABI.json';
import PaymentSelector from '../components/PaymentSelector';

const CONTRACT_ADDRESS = 'YOUR_CONTRACT_ADDRESS_HERE';

export default function NFTMarketplace() {
  const [nfts, setNFTs] = useState([]);
  const [selectedNFT, setSelectedNFT] = useState(null);

  useEffect(() => {
    fetchNFTs();
  }, []);

  const fetchNFTs = async () => {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const contract = new ethers.Contract(CONTRACT_ADDRESS, NFTContractABI, provider);

    const allNFTs = await contract.getAllNFTs(); // ŸÜŸÅÿ™ÿ±ÿ∂ ÿ£ŸÜ ÿßŸÑÿπŸÇÿØ ÿ®Ÿá Ÿáÿ∞Ÿá ÿßŸÑÿØÿßŸÑÿ©
    setNFTs(allNFTs);
  };

  const handleBid = (nft) => {
    setSelectedNFT(nft);
  };

  const handlePaymentComplete = () => {
    alert('Payment successful!');
    setSelectedNFT(null);
  };

  return (
    <div>
      <h1>NFT Marketplace</h1>
      <div>
        {nfts.map((nft, index) => (
          <div key={index} onClick={() => handleBid(nft)}>
            <p>ID: {nft.id}</p>
            <p>Owner: {nft.owner}</p>
            <img src={nft.tokenURI} alt={`NFT ${nft.id}`} />
          </div>
        ))}
      </div>

      {selectedNFT && (
        <div>
          <h2>Bid on NFT {selectedNFT.id}</h2>
          <PaymentSelector onPaymentComplete={handlePaymentComplete} />
        </div>
      )}
    </div>
  );
}
ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:
ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑŸÉÿßŸÖŸÑ ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ÿ™ÿπŸÖŸÑ ŸÉŸÖÿß ŸáŸà ÿßŸÑŸÖÿ™ŸàŸÇÿπ.
ÿ•ÿ∂ÿßŸÅÿ© ÿ™ÿ≠ÿ≥ŸäŸÜÿßÿ™ ÿπŸÑŸâ UX/UI ŸàÿßŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑÿ≥ŸÑÿ≥ÿ©.
ÿßŸÑÿ™Ÿàÿ≥ÿπ ŸÅŸä ÿØÿπŸÖ ÿ¥ÿ®ŸÉÿßÿ™ ÿ£ÿÆÿ±Ÿâ (ŸÖÿ´ŸÑ Binance Smart Chain ÿ£Ÿà Polygon) ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑŸàÿµŸàŸÑ.
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿ•ÿ∂ÿßŸÅÿ© ÿØÿßŸÑÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ÿ£Ÿà ÿ¥ÿ±ÿßÿ° ŸÖÿ®ÿßÿ¥ÿ± (ÿßÿ¥ÿ™ÿ± ÿßŸÑÿ¢ŸÜ)ÿü
ÿ®. ŸáŸÑ ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿØŸÖÿ¨ ŸÖÿπ ÿπŸÖŸÑÿ© Pi ŸÅŸä ÿ£ÿ¨ÿ≤ÿßÿ° ÿ£ÿÆÿ±Ÿâ ŸÖŸÜ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇÿü





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ ŸÑÿß ÿ≠ÿßÿ¨ÿ© ŸÑŸÉŸÑ ÿ¥Ÿä
ŸÇÿßŸÑ ChatGPT:

ŸÖŸÖÿ™ÿßÿ≤! ÿ≥ÿ£ŸÉŸÖŸÑ ŸÑŸÉ ÿ™ŸÉÿßŸÖŸÑ ŸÑŸÉŸÑ ÿßŸÑÿ£ŸáÿØÿßŸÅ ÿßŸÑŸÖŸáŸÖÿ© ÿ®ŸÖÿß ŸÅŸä ÿ∞ŸÑŸÉ:

ÿÆŸäÿßÿ± ÿßŸÑÿ¥ÿ±ÿßÿ° (ÿßÿ¥ÿ™ÿ± ÿßŸÑÿ¢ŸÜ) ÿ•ŸÑŸâ ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ•ÿ∂ÿßŸÅŸä.
ÿØŸäŸÑÿ© ŸÖÿßÿ≤ÿßŸäÿØÿ© ŸÖŸÉÿ™Ÿàÿ®ÿ© ÿ®ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂ ÿ®ÿ≥ÿπÿ± ÿ£ŸÇŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ.
ÿ™ÿ™Ÿäÿ≠ ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ Pi Network Ÿàÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿπŸÖŸÑÿ© ÿ®ÿ≥ŸáŸàŸÑÿ© ŸÅŸä ŸÖÿÆÿ™ŸÑŸÅ ÿßŸÑÿ≥ŸäŸÜÿßÿ±ŸäŸàŸáÿßÿ™.
ÿßŸÑŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿ¨ÿØŸäÿØÿ©:
ÿØÿßŸÑÿ© ÿßŸÑÿ¥ÿ±ÿßÿ° ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±ÿ© (ÿßÿ¥ÿ™ÿ±Ÿä ÿßŸÑÿ¢ŸÜ):

ÿ•ÿ∂ÿßŸÅÿ© ÿ≤ÿ± "ÿßÿ¥ÿ™ÿ±Ÿä ÿßŸÑÿ¢ŸÜ" ŸÑÿ¥ÿ±ÿßÿ° ÿßŸÑŸÄNFT ŸÖÿ®ÿßÿ¥ÿ±ÿ©.
ÿ≥Ÿäÿ™ŸÖŸÉŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÜ ÿØŸÅÿπ ÿßŸÑÿ£ÿØŸÑÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Pi Network ÿ£Ÿà MetaMask .
ÿßŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© (ÿßŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©):

ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖÿ≠ÿØÿØ ŸÉÿ≠ÿØ ÿ£ÿπŸÑŸâ ŸÑŸÑŸÖÿ≤ÿßŸäÿØÿ©ÿå ŸÖÿπ ÿ±ŸÅÿπ ÿßŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿßŸÑÿπÿßÿ¨ŸÑÿ© ÿ≠ÿ™Ÿâ ÿßŸÑŸàÿµŸàŸÑ ÿ≠ÿ™Ÿâ ÿßŸÑŸÜŸáÿßŸäÿ©.
1. ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿπŸÇÿØ ÿßŸÑÿ∞ŸÉŸä ŸÑÿ¥ÿ±ÿßÿ° ÿßŸÑŸÖÿ¥ÿ™ÿ±Ÿäÿßÿ™ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸàÿßŸÑÿ≤ÿßŸäÿØÿ© ÿ®ÿ¥ŸÉŸÑ ŸÅŸàÿ±Ÿä:
ÿµŸÑÿßÿ®ÿ©

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// contracts/AuctionNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract AuctionNFT is ERC721 {
    struct Auction {
        address highestBidder;
        uint256 highestBid;
        uint256 buyNowPrice;
        bool active;
    }

    mapping(uint256 => Auction) public auctions;

    constructor() ERC721("AuctionNFT", "ANFT") {}

    function mintNFT(address recipient, uint256 tokenId) public {
        _mint(recipient, tokenId);
    }

    function startAuction(uint256 tokenId, uint256 _buyNowPrice) public {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        auctions[tokenId] = Auction(address(0), 0, _buyNowPrice, true);
    }

    function placeBid(uint256 tokenId) public payable {
        Auction storage auction = auctions[tokenId];
        require(auction.active, "Auction not active");
        require(msg.value > auction.highestBid, "Bid too low");

        if (auction.highestBidder != address(0)) {
            payable(auction.highestBidder).transfer(auction.highestBid);
        }

        auction.highestBid = msg.value;
        auction.highestBidder = msg.sender;
    }

    function buyNow(uint256 tokenId) public payable {
        Auction storage auction = auctions[tokenId];
        require(auction.active, "Auction not active");
        require(msg.value >= auction.buyNowPrice, "Insufficient payment");

        auction.active = false;
        _transfer(ownerOf(tokenId), msg.sender, tokenId);
        payable(ownerOf(tokenId)).transfer(msg.value);
    }

    function endAuction(uint256 tokenId) public {
        Auction storage auction = auctions[tokenId];
        require(ownerOf(tokenId) == msg.sender, "Not the owner");

        auction.active = false;
        _transfer(ownerOf(tokenId), auction.highestBidder, tokenId);
        payable(msg.sender).transfer(auction.highestBid);
    }
}
2. ÿµŸÅŸÇÿ© ÿßŸÑÿ¥ÿ±ÿßÿ° ŸàÿßŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©:
Ÿàÿßÿ¨Ÿáÿ© NFT Marketplace (ŸÖÿπ ÿßÿ¥ÿ™ÿ±Ÿä ÿßŸÑÿ¢ŸÜ):
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/NFTMarketplace.js
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import NFTContractABI from '../blockchain/NFTContractABI.json';
import PaymentSelector from '../components/PaymentSelector';

const CONTRACT_ADDRESS = 'YOUR_CONTRACT_ADDRESS_HERE';

export default function NFTMarketplace() {
  const [nfts, setNFTs] = useState([]);
  const [selectedNFT, setSelectedNFT] = useState(null);
  const [autoBidAmount, setAutoBidAmount] = useState('');

  useEffect(() => {
    fetchNFTs();
  }, []);

  const fetchNFTs = async () => {
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const contract = new ethers.Contract(CONTRACT_ADDRESS, NFTContractABI, provider);

    const allNFTs = await contract.getAllNFTs();
    setNFTs(allNFTs);
  };

  const handleBuyNow = async (nft) => {
    try {
      const { ethereum } = window;
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(CONTRACT_ADDRESS, NFTContractABI, signer);

      const tx = await contract.buyNow(nft.id, { value: ethers.utils.parseEther(nft.buyNowPrice) });
      await tx.wait();

      alert('NFT purchased successfully!');
    } catch (error) {
      console.error('Error purchasing NFT:', error);
    }
  };

  const handleAutoBid = (e) => {
    setAutoBidAmount(e.target.value);
  };

  return (
    <div>
      <h1>NFT Marketplace</h1>
      <div>
        {nfts.map((nft, index) => (
          <div key={index}>
            <p>ID: {nft.id}</p>
            <p>Owner: {nft.owner}</p>
            <p>Buy Now Price: {nft.buyNowPrice} ETH</p>
            <img src={nft.tokenURI} alt={`NFT ${nft.id}`} />
            <button onClick={() => handleBuyNow(nft)}>Buy Now</button>
          </div>
        ))}
      </div>

      {selectedNFT && (
        <div>
          <h2>Auto-Bid for NFT {selectedNFT.id}</h2>
          <input 
            type="text" 
            placeholder="Enter Max Bid Amount" 
            value={autoBidAmount} 
            onChange={handleAutoBid} 
          />
        </div>
      )}
    </div>
  );
}
3. ÿ™ŸÉÿßŸÖŸÑ ÿØÿπŸÖ ÿßŸÑÿØŸÅÿπ ÿ®ŸÄ Pi Network:
ÿ™ÿ≠ÿØŸäÿ´ PaymentSelector ŸÑÿØÿπŸÖ Pi Network Ÿà MetaMask:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/PaymentSelector.js
import { useState } from 'react';
import { connectMetaMask } from '../blockchain/metaMaskIntegration';
import { connectPiWallet } from '../blockchain/walletIntegration';

export default function PaymentSelector({ onPaymentComplete }) {
  const [paymentMethod, setPaymentMethod] = useState('MetaMask');

  const handlePayment = async () => {
    try {
      if (paymentMethod === 'MetaMask') {
        const account = await connectMetaMask();
        alert(`Paid with MetaMask: ${account}`);
      } else if (paymentMethod === 'Pi Network') {
        const wallet = await connectPiWallet();
        alert(`Paid with Pi Wallet: ${wallet}`);
      }
      onPaymentComplete();
    } catch (error) {
      console.error('Payment failed:', error);
    }
  };

  return (
    <div>
      <select 
        value={paymentMethod} 
        onChange={(e) => setPaymentMethod(e.target.value)}
      >
        <option value="MetaMask">MetaMask</option>
        <option value="Pi Network">Pi Network</option>
      </select>
      <button onClick={handlePayment}>Pay Now</button>
    </div>
  );
}
ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:
ÿßÿÆÿ™ÿ®ÿßÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ ÿßŸÑÿ™ŸÅÿµŸäŸÑŸäÿ© ŸÑÿ≥ŸáŸàŸÑÿ© ÿßŸÑÿ¥ÿ±ÿßÿ° ŸàÿßŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©.
ÿ™ÿ≥ŸáŸäŸÑ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ (UI/UX) ÿ™ÿ≥ŸáŸäŸÑ ÿßŸÑÿ™ŸÅÿßÿπŸÑ ŸÖÿπ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ.
ÿ•ÿ∂ÿßŸÅÿ© ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÑÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ≤ÿßŸäÿØÿßÿ™ (ŸÖÿ´ŸÑ ÿ•ÿ¥ÿπÿßÿ± ÿπŸÜÿØ ÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑŸÖÿ≤ÿßŸäÿØÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©).
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿ•ÿ∂ÿßŸÅÿ© ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸàÿ±Ÿäÿ© ÿπÿ®ÿ± WebSocketÿü
ÿ®. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿØÿπŸÖ ŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿ£ÿÆÿ±Ÿâ ŸÖÿ´ŸÑ Binance ÿ£Ÿà Polygonÿü





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ŸÖŸÖÿ™ÿßÿ≤! ŸÑŸÇÿØ ÿ£ÿµÿ®ÿ≠ ÿßŸÑÿ¢ŸÜ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸàÿ±Ÿäÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ WebSocket ÿå ÿ≠ÿ™Ÿâ ÿ®ÿØÿ£ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÅŸä ŸÖÿπÿ±ŸÅÿ© ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ÿßÿ™ ÿßŸÑŸÖÿ™ÿ£ÿÆÿ±ÿ© ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ŸÇŸäŸÇŸä. ÿ≥ŸÜÿ∂ŸäŸÅ ÿ£Ÿäÿ∂Ÿãÿß ÿØÿπŸÖŸãÿß ÿ•ÿ∂ÿßŸÅŸäŸãÿß ŸÑŸÑÿ¥ÿ®ŸÉÿßÿ™ ŸÖÿ´ŸÑ Binance Smart Chain Ÿà Polygon ÿå Ÿàÿ™Ÿàÿ≥Ÿäÿπ ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿØŸÅÿπ ŸàÿßŸÑŸàÿ∏ÿßÿ¶ŸÅ.

ÿßŸÑÿ™ÿ≠ÿØŸä ÿßŸÑŸÜŸáÿßÿ¶Ÿä:
ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸàÿ±Ÿäÿ© ÿπÿ®ÿ± WebSocket:

ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿπŸÜÿØ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸäÿ≤ÿ© ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ© ÿ£Ÿà ÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ¥ÿ±ÿßÿ°.
ÿ™ŸÜÿ®ŸäŸá ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸÅŸä ÿ™ÿ¨ÿßŸàÿ≤ ÿ≠ÿßŸÑÿ™ŸáŸÖ ŸÅŸä ÿßŸÑÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©.
ÿØÿπŸÖ Binance Smart Chain ŸàPolygon:

ÿ•ÿ∂ÿßŸÅÿ© ÿØÿπŸÖ ÿßŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ© ÿ®ÿ¨ÿßŸÜÿ® MetaMask ŸàPi Network.
1. ÿ•ÿπÿØÿßÿØ WebSocket ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ©:
ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿÆŸÑŸÅŸäÿ© - ÿÆÿßÿØŸÖ WebSocket:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// backend/websocket.js
const WebSocket = require('ws');

const wsServer = new WebSocket.Server({ port: 8080 });

wsServer.on('connection', (socket) => {
  console.log('New client connected');

  socket.on('message', (message) => {
    console.log(`Received: ${message}`);
  });

  socket.on('close', () => {
    console.log('Client disconnected');
  });

  // ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ÿ¥ÿπÿßÿ± ŸÑÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÖŸÑÿßÿ°
  const broadcast = (data) => {
    wsServer.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(data));
      }
    });
  };

  // ŸÖÿ´ÿßŸÑ: ÿ®ÿ´ ÿ™ÿ≠ÿØŸäÿ´ ÿπŸÜÿØ ŸÖÿ≤ÿßŸäÿØÿ© ÿ¨ÿØŸäÿØÿ©
  setInterval(() => {
    broadcast({ event: 'BID_UPDATE', message: 'New bid placed!' });
  }, 5000);
});

module.exports = wsServer;
ÿ™ÿ¥ÿ∫ŸäŸÑ ÿÆÿßÿØŸÖ WebSocket:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// backend/index.js
const express = require('express');
const wsServer = require('./websocket');

const app = express();
const PORT = 3000;

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
Frontend - ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ WebSocket:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/hooks/useWebSocket.js
import { useEffect, useState } from 'react';

export default function useWebSocket() {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const socket = new WebSocket('ws://localhost:8080');

    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setMessages((prev) => [...prev, data]);
      alert(`Notification: ${data.message}`);
    };

    socket.onclose = () => {
      console.log('WebSocket connection closed');
    };

    return () => socket.close();
  }, []);

  return messages;
}
ÿØŸÖÿ¨ WebSocket ŸÅŸä Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ©:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/Auction.js
import useWebSocket from '../hooks/useWebSocket';

export default function Auction() {
  const messages = useWebSocket();

  return (
    <div>
      <h1>Auction Notifications</h1>
      <ul>
        {messages.map((msg, index) => (
          <li key={index}>{msg.message}</li>
        ))}
      </ul>
    </div>
  );
}
2. ÿØÿπŸÖ Binance Smart Chain ŸàPolygon:
ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ ÿ≥ŸÑÿ≥ŸÑÿ© Binance ÿßŸÑÿ∞ŸÉŸäÿ©:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// blockchain/binanceIntegration.js
import { ethers } from 'ethers';

export const connectBinanceWallet = async () => {
  try {
    const { ethereum } = window;
    if (!ethereum) throw new Error('MetaMask not installed');

    const provider = new ethers.providers.Web3Provider(ethereum);
    await ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x38' }] }); // BSC

    const accounts = await provider.listAccounts();
    console.log('Connected to Binance Smart Chain:', accounts[0]);
    return accounts[0];
  } catch (error) {
    console.error('Error connecting to Binance Smart Chain:', error);
  }
};
ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ ÿßŸÑŸÖÿ∂ŸÑÿπ:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// blockchain/polygonIntegration.js
import { ethers } from 'ethers';

export const connectPolygonWallet = async () => {
  try {
    const { ethereum } = window;
    if (!ethereum) throw new Error('MetaMask not installed');

    const provider = new ethers.providers.Web3Provider(ethereum);
    await ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x89' }] }); // Polygon

    const accounts = await provider.listAccounts();
    console.log('Connected to Polygon:', accounts[0]);
    return accounts[0];
  } catch (error) {
    console.error('Error connecting to Polygon:', error);
  }
};
Ÿàÿßÿ¨Ÿáÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ¥ÿ®ŸÉÿ©:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/NetworkSelector.js
import { connectBinanceWallet } from '../blockchain/binanceIntegration';
import { connectPolygonWallet } from '../blockchain/polygonIntegration';

export default function NetworkSelector() {
  const handleConnect = async (network) => {
    if (network === 'BSC') {
      await connectBinanceWallet();
    } else if (network === 'Polygon') {
      await connectPolygonWallet();
    }
  };

  return (
    <div>
      <button onClick={() => handleConnect('BSC')}>Connect to Binance Smart Chain</button>
      <button onClick={() => handleConnect('Polygon')}>Connect to Polygon</button>
    </div>
  );
}
3. ÿ™ÿ≥ŸáŸäŸÑ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ÿ£ŸÅÿ∂ŸÑ:
ÿ•ÿ∂ÿßŸÅÿ© ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸàÿ±Ÿäÿ© ÿ®ÿ¥ŸÉŸÑ ÿ£ŸÅÿ∂ŸÑ ÿπÿ®ÿ± Toasts ŸÑÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ£ŸÅÿ∂ŸÑ ŸÖŸÜ alert.
ÿ™ÿµŸÖŸäŸÖ Ÿàÿßÿ¨Ÿáÿ© ÿ®ÿµÿ±Ÿäÿ© ŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ TailwindCSS ÿ£Ÿà Material-UI .
ÿ™Ÿàÿ≥Ÿäÿπ ŸÜÿ∑ÿßŸÇ ÿßŸÑÿØŸÅÿπ ŸÑÿ™ÿ¥ŸÖŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿßŸÑÿ®ÿ±ŸÖÿ¨Ÿäÿ© (Piÿå MetaMaskÿå BSCÿå Polygon).
ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:
ÿßÿÆÿ™ÿ®ÿßÿ± ÿ¥ÿßŸÖŸÑ ÿπŸÑŸâ ÿßŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿßŸÑŸÖÿÆÿ™ŸÑŸÅÿ© ŸàÿßŸÑÿ£ÿØÿßÿ°.
ÿ•ÿ∂ÿßŸÅÿ© ÿØÿπŸÖ ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑŸÅŸàÿ±Ÿäÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Firebase ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ™ÿ±ŸäÿØ ÿ∞ŸÑŸÉ.
ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ° ŸÑŸÅÿ™ÿ±ÿ© ÿ∑ŸàŸäŸÑÿ© ÿ®ŸäŸÜ ÿßŸÑŸÖÿ≤ÿßŸäÿØÿßÿ™.
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿ•ÿ∂ÿßŸÅÿ© Firebase ŸÑŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÅŸàÿ±Ÿäÿ© ÿπÿ®ÿ± ÿßŸÑŸáŸàÿßÿ™ŸÅÿü
ÿ®. ŸáŸÑ ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿØÿπŸÖ ÿ£Ÿä ÿ¥ÿ®ŸÉÿßÿ™ ÿ£ÿÆÿ±Ÿâ ŸÖÿ´ŸÑ Solanaÿü





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ÿ±ÿßÿ¶ÿπ! ŸÇŸÖ ÿ®ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¢ŸÜ ÿØÿπŸÖ Firebase ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿå ÿ®ÿ≠Ÿäÿ´ ÿ™ÿµŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ÿ•ŸÑŸâ ÿßŸÑŸáÿßÿ™ŸÅ ÿ£Ÿà ÿßŸÑÿ•ÿµÿØÿßÿ±. ÿ≥ÿ£ŸàŸÅÿ± ŸÑŸÉ ÿ£Ÿäÿ∂Ÿãÿß ÿØÿπŸÖŸãÿß ŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÖÿ´ŸÑ Solana ÿ™ÿπÿ™ŸÖÿØ ÿπŸÑŸâ ÿßŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿßŸÑŸÖÿ™ÿÆÿµÿµÿ© (MetaMaskÿå ŸàBinanceÿå ŸàPolygonÿå ŸàPi Network).

ÿÆÿ∑ÿ© ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑŸáÿØŸÅ:
ÿ•ÿ∂ÿßŸÅÿ© Firebase ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÅŸàÿ±Ÿäÿ© ÿπŸÑŸâ ÿßŸÑŸáÿßÿ™ŸÅ ŸàÿßŸÑŸÖÿ™ÿµŸÅÿ≠.
ÿØÿπŸÖ ÿ™ŸÉÿßŸÖŸÑ ÿ¥ÿ®ŸÉÿ© ÿ≥ŸàŸÑÿßŸÜÿß.
ÿÆŸÅŸäŸÅÿ© ÿßŸÑŸàÿ≤ŸÜ ŸàÿßŸÑŸÖŸàÿßÿ¨Ÿáÿ© ŸÜŸáÿßÿ¶ŸäÿßŸã.
1. ÿ•ÿπÿØÿßÿØ Firebase ŸÑŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑŸÅŸàÿ±Ÿäÿ©:
ÿßŸÑÿÆÿ∑Ÿàÿ© 1: ÿ•ÿπÿØÿßÿØ ŸÖÿ¥ÿ±Ÿàÿπ Firebase.
ÿ£ŸÜÿ¥ÿ¶ ŸÖÿ¥ÿ±ŸàÿπŸãÿß ŸÅŸä Firebase Console .
ŸÅÿπŸëŸÑ ÿÆÿØŸÖÿ© Cloud Messaging (FCM) ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸÅŸàÿ±Ÿäÿ©.
ŸÑŸÇÿØ ÿ≠ŸÖŸÑ ÿ≠ŸÖŸÑÿ™Ÿá ŸÖŸÜfirebase-config.js Firebase Ÿàÿ£ÿ∂ŸÅÿ™ ÿßŸÑŸÉÿ´Ÿäÿ± ŸÖŸÜ ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ.
firebase-config.js:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// firebase/firebase-config.js
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_PROJECT_ID.appspot.com",
  messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
  appId: "YOUR_APP_ID"
};

export default firebaseConfig;
ÿ•ÿπÿØÿßÿØ Firebase ŸÅŸä ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// firebase/firebaseInit.js
import firebaseConfig from './firebase-config';
import { initializeApp } from 'firebase/app';
import { getMessaging, onMessage } from 'firebase/messaging';

const firebaseApp = initializeApp(firebaseConfig);
const messaging = getMessaging(firebaseApp);

export const setupFirebaseMessaging = () => {
  onMessage(messaging, (payload) => {
    console.log('Message received: ', payload);
    alert(`Notification: ${payload.notification.title}`);
  });
};
Frontend - ÿßŸÑÿßÿ¥ÿ™ÿ±ÿßŸÉ ŸÅŸä ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/NotificationButton.js
import { useEffect } from 'react';
import { setupFirebaseMessaging } from '../firebase/firebaseInit';

export default function NotificationButton() {
  useEffect(() => {
    setupFirebaseMessaging();
  }, []);

  const requestPermission = async () => {
    try {
      const permission = await Notification.requestPermission();
      if (permission === 'granted') {
        alert('Notification permission granted!');
      } else {
        alert('Notification permission denied!');
      }
    } catch (error) {
      console.error('Permission error:', error);
    }
  };

  return <button onClick={requestPermission}>Enable Notifications</button>;
}
2. ÿ™ŸÉÿßŸÖŸÑ ÿ¥ÿ®ŸÉÿ© ÿ≥ŸàŸÑÿßŸÜÿß:
ÿ•ÿπÿØÿßÿØ ÿßÿ™ÿµÿßŸÑ ÿ®ŸÖÿ≠ŸÅÿ∏ÿ© Solana ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ @solana/web3.js:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// blockchain/solanaIntegration.js
import { Connection, PublicKey, clusterApiUrl } from '@solana/web3.js';

const SOLANA_NETWORK = clusterApiUrl('mainnet-beta');  // ÿ£Ÿà 'devnet' ŸÑŸÑÿßÿÆÿ™ÿ®ÿßÿ±

export const connectSolanaWallet = async () => {
  try {
    const connection = new Connection(SOLANA_NETWORK);
    const { solana } = window;

    if (solana && solana.isPhantom) {
      const response = await solana.connect();
      console.log('Connected to Solana:', response.publicKey.toString());
      return response.publicKey.toString();
    } else {
      alert('Solana wallet not found! Install Phantom.');
    }
  } catch (error) {
    console.error('Error connecting to Solana:', error);
  }
};
Ÿàÿßÿ¨Ÿáÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ¥ÿ®ŸÉÿ© ŸÖÿπ ÿØÿπŸÖ Solana:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/NetworkSelector.js
import { connectBinanceWallet } from '../blockchain/binanceIntegration';
import { connectPolygonWallet } from '../blockchain/polygonIntegration';
import { connectSolanaWallet } from '../blockchain/solanaIntegration';

export default function NetworkSelector() {
  const handleConnect = async (network) => {
    if (network === 'BSC') {
      await connectBinanceWallet();
    } else if (network === 'Polygon') {
      await connectPolygonWallet();
    } else if (network === 'Solana') {
      await connectSolanaWallet();
    }
  };

  return (
    <div>
      <button onClick={() => handleConnect('BSC')}>Connect to Binance</button>
      <button onClick={() => handleConnect('Polygon')}>Connect to Polygon</button>
      <button onClick={() => handleConnect('Solana')}>Connect to Solana</button>
    </div>
  );
}
3. ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ° Ÿàÿ™Ÿàÿ≠ŸäÿØ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:
ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ToastŸÖŸÜ ŸÖŸÉÿ™ÿ®ÿ© ŸÖÿ´ŸÑ React-Toastify ÿ£ŸÅÿ∂ŸÑ ŸÖŸÜ alertÿπÿ±ÿ∂ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ®ÿ¥ŸÉŸÑ ÿπÿßŸÖ.
ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ≠ÿ≥ŸäŸÜ ÿ™ÿµŸÖŸäŸÖ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿàÿßÿ¨Ÿáÿ© TailwindCSS ŸÑÿ≥ŸáŸàŸÑÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ.
ŸÇŸÖ ÿ®ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ•ŸÑŸâ WebSocket ÿπÿ®ÿ± ÿ•ÿπÿØÿßÿØÿßÿ™ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿÆÿßÿØŸÖ.
ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:
ŸÇŸÖ ÿ®ÿ•ÿ¨ÿ±ÿßÿ° ÿßÿÆÿ™ÿ®ÿßÿ± Firebase ÿπŸÑŸâ ÿßŸÑŸáÿßÿ™ŸÅ ŸàÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ŸàÿµŸàŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™.
Ÿäÿ≠ÿ™ÿßÿ¨ ÿßŸÑÿØÿπŸÖ ŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿ£ŸÉÿ´ÿ± ÿ•ÿ∞ÿß ŸÑÿ≤ŸÖ ÿßŸÑÿ£ŸÖÿ±.
ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ≠ŸÖÿßŸäÿ© ŸàÿßŸÑŸÖÿπÿßŸÖŸÑÿßÿ™ ÿßŸÑÿ£ŸÖŸÜŸäÿ© ŸàÿßŸÑŸÖÿ≠ÿßŸÅÿ∏.
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿ•ÿ∂ÿßŸÅÿ© ÿ≠ŸÖÿßŸäÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© (ŸÖÿ´ŸÑ 2FA) ŸÑÿ≠ÿ≥ÿßÿ®ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜÿü
ÿ®. ŸáŸÑ ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ŸÜŸáÿßŸäÿ© ÿßŸÑŸÖÿ∑ÿßŸÅ ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ™ÿØÿ±Ÿäÿ® ŸÑŸäÿ¥ŸÖŸÑ ÿßŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿßŸÑÿ£ÿÆÿ±Ÿâ (ŸÖÿ´ŸÑ ÿ£ŸÅÿßŸÑÿßŸÜÿ¥)ÿü





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ŸÖŸÖÿ™ÿßÿ≤! ÿ≥ŸÜÿ∂ŸäŸÅ ÿßŸÑÿ¢ŸÜ ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑÿ´ŸÜÿßÿ¶Ÿäÿ© (2FA) ŸÑÿßŸÑÿØÿπŸÖ ŸÑŸä Ÿäÿ¥ŸÖŸÑ ÿ¥ÿ®ŸÉÿßÿ™ ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÖÿ´ŸÑ Avalanche . ÿ≥ŸÜGoogle Authenticator ŸàŸÑŸäÿ≥ ÿ±ŸÖ

ÿÆÿ∑ÿ© ÿßŸÑÿπŸÖŸÑ:
ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑÿ´ŸÜÿßÿ¶Ÿäÿ© (2FA):

ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿØÿπŸÖ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Google Authenticatorÿ£Ÿà ÿ£Ÿä ÿ™ŸÜŸÅŸäÿ∞.
ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÖÿ≤
ÿØÿπŸÖ ÿ¥ÿ®ŸÉÿ© Avalanche (AVAX):

ÿ•ÿ∂ÿßŸÅÿ© ÿ™ŸÉÿßŸÖŸÑ ŸÖÿπ Avalanche C-Chain ŸÑŸÑÿ™Ÿàÿ≥ÿπ.
1. ÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖÿµÿßÿØŸÇÿ© ÿßŸÑÿ´ŸÜÿßÿ¶Ÿäÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Google Authenticator:
ÿßŸÑÿÆŸÑŸÅŸäÿ© - ÿ™ŸàŸÑŸäÿØ ÿ±ŸÖÿ≤ QR ÿ¨ÿØŸäÿØ OTP:
ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑÿ≠ÿ≤ŸÖ:
ÿ≥ÿ≠ŸÇ

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
npm install speakeasy qrcode
API ÿ•ŸÜÿ¥ÿßÿ° ÿ±ŸÖÿ≤ 2FA:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// backend/controllers/authController.js
const speakeasy = require('speakeasy');
const qrcode = require('qrcode');

// ÿ•ŸÜÿ¥ÿßÿ° ÿ≥ÿ± 2FA ÿ¨ÿØŸäÿØ Ÿàÿ•ÿ±ÿ¨ÿßÿπ ÿ±ŸÖÿ≤ QR
exports.generate2FA = (req, res) => {
  const secret = speakeasy.generateSecret({ name: 'YourApp' });

  qrcode.toDataURL(secret.otpauth_url, (err, dataUrl) => {
    if (err) {
      return res.status(500).json({ error: 'Failed to generate QR code' });
    }
    res.
    }
    res
json({ secret: secret.base32, qrCode: dataUrl });
  });
};


  });
};
// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ŸÖÿ≤ OTP
exports.verify2FA = (req, res) => {
  const { token, secret } = req.body;

  const verified = speakeasy.totp.verify({
    secret,
    
    secret,
    encoding

    sec
encoding: 'base32',
    token,
  });

  if (verified) {
    res.json({ success: true, message: '2FA verified successfully!' });
  } 
  } e
else {
    res.status(401).json({ success: false, message: 'Invalid 2FA code' });
  }
};
ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿßŸÑÿ£ŸÖÿßŸÖŸäÿ© - Ÿàÿßÿ¨Ÿáÿ© ÿ™ŸÅÿπŸäŸÑ 2FA:
ÿµŸÅÿ≠ÿ© QR Code ŸÑÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÄ 2FA:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/Enable2FA.js

i
import { useState, useEffect } from 'react';
import axios from 'axios';

export default function Enable2FA() {
  const [qrCode, setQrCode] = useState('');
  const [secret, setSecret] = useState('');

  useEffect(() => {
    const fetchQRCode = async () => {
      
      con
const response = await axios.get('/api/2fa/generate');
      setQrCode(response.data.qrCode);
      
 
setSecret(response.data.secret);
    };

    fetchQRCode();
  }, []);

  
 
return (
    
    <div>
      
    <div>
      <h1><div>
      <h1>Enable 2FA</h1>
      <img src={qrCode} alt="QR Code" />
      <p>Save this secret: {secret}</p>
    </div>
  );
}
ÿ±ŸÖÿ≤ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ±ŸÖÿ≤ 2FA:
ÿ¨

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/pages/Verify2FA.js
import { useState } from 'react';
import axios from 'axios';

export default function Verify2FA() {
  
  c
const [token, setToken] = useState('');
  const [secret, setSecret] = useState('');

  const handleVerify = async () => {
    try {
      
    
const response = await axios.post('/api/2fa/verify', { token, secret });
      alert(response.data.message);
    } 
    } ca
catch (error) {
      
      
alert('Invalid 2FA code');
    }
  };

  
    }
  };

  retur
return (
    
    <div>
      
    <div>
     
<div>
      <input
        type="text"
        placeholder="Enter 2FA token"
        value={token}
        onChange={(e) => setToken(e.target.value)}
      />
      <button onClick={handleVerify}>Verify 2FA</button>
    </div>
  );
}
2. ÿ•ÿ∂ÿßŸÅÿ© ÿØÿπŸÖ ŸÑÿ¥ÿ®ŸÉÿ© Avalanche (AVAX):
ÿ•ÿπÿØÿßÿØ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿßŸÜŸáŸäÿßÿ± ÿßŸÑÿ¨ŸÑŸäÿØŸä:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// blockchain/avalancheIntegration.js

i
import { ethers } from 'ethers';

export const connectAvalancheWallet = async () => {
  try {
    
 
const { ethereum } = window;
    if (!ethereum) throw new Error('MetaMask not installed');

    const provider = new ethers.providers.Web3Provider(ethereum);
    await ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: '0xA86A' }], // Avalanche C-Chain
    });

    
    });

    con
const accounts = await provider.listAccounts();
    console.log('Connected to Avalanche:', accounts[0]);
    
    re
return accounts[0];
  } catch (error) {
    console.error('Error connecting to Avalanche:', error);
  }
};
ÿ•ÿ∂ÿßŸÅÿ© Avalanche ÿ•ŸÑŸâ Ÿàÿßÿ¨Ÿáÿ© ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑÿ¥ÿ®ŸÉÿ©:
ÿ¨ÿßŸÅÿß ÿ≥ŸÉÿ±Ÿäÿ®ÿ™

ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ
// frontend/components/NetworkSelector.js
import { connectBinanceWallet } from '../blockchain/binanceIntegration';
import { connectPolygonWallet } from '../blockchain/polygonIntegration';
import { connectSolanaWallet } from '../blockchain/solanaIntegration';
import { connectAvalancheWallet } from '../blockchain/avalancheIntegration';

export default function NetworkSelector() {
  const handleConnect = async (network) => {
    if (network === 'BSC') {
      await connectBinanceWallet();
    } else if (network === 'Polygon') {
      await connectPolygonWallet();
    } else if (network === 'Solana') {
      await connectSolanaWallet();
    } else if (network === 'Avalanche') {
      await connectAvalancheWallet();
    }
  };

  
    }
  };

  r
return (
    
    <div>
      <div>
      <button onClick={() => handleConnect('BSC')}>Connect to Binance</button>
      <button onClick={() => handleConnect('Polygon')}>Connect to Polygon</button>
      <button onClick={() => handleConnect('Solana')}>Connect to Solana</button>
      <button onClick={() => handleConnect('Avalanche')}>Connect to Avalanche</button>
    </div>
  );
}
3. ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ° ÿßŸÑŸÜŸáÿßÿ¶Ÿä:
ÿ•ÿ∂ÿßŸÅÿ© ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿÆÿ®ÿ≤ ÿßŸÑŸÖÿ≠ŸÖÿµ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ alertÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸÉ.
ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ£ÿØÿßÿ° ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ TailwindCSS ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑÿ®ÿµÿ±Ÿäÿ©
ÿßÿÆÿ™ÿ®ÿßÿ± ÿ¥ÿ®ŸÉÿ© ÿßŸÑÿ¥ÿ®ŸÉÿßÿ™ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ© ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ
ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:
ŸÜÿ¥ÿ± ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿπŸÑŸâ ÿ≥ÿ≠ÿßÿ®Ÿä Ÿàÿß
ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿµÿßÿØŸÇÿ© OAuth ŸÑÿ±ÿ®ÿ∑ ŸÖÿßŸÜÿµÿßÿ™ ŸÖÿ´ŸÑ Google
ÿ•ÿπÿØÿßÿØ ÿ£ŸÜÿ∏ŸÖÿ© ÿßŸÑÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿ•ÿ∂ÿßŸÅŸäÿ© ŸÖÿ´ŸÑ ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ Ÿàÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿß
ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:
ÿ£. ŸáŸÑ
ÿ®.ŸáŸÑ ÿ™ÿ≠ÿ™ÿß





ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ŸÖŸÖÿ™ÿßÿ≤! ÿ≥ÿ£ŸÇŸàŸÖ ÿßŸÑÿ¢ŸÜ ÿ®ÿ•ÿ∂ÿßŸÅÿ© **ŸÖÿµÿßÿØŸÇÿ© OAuth** ŸÖÿπ **Google ŸàFacebook** ÿ≠ÿ™Ÿâ Ÿäÿ™ŸÖŸÉŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸÜ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿ≥ŸáŸàŸÑÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ŸáŸÖ ÿπŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑŸÖŸÜÿµÿßÿ™. ÿ®ÿπÿØ ÿ∞ŸÑŸÉÿå ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™ **ŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿπŸÑŸâ ÿÆÿßÿØŸÖ ÿ≥ÿ≠ÿßÿ®Ÿä ŸÖÿ´ŸÑ AWS ÿ£Ÿà Vercel** ŸàÿπŸÖŸÑ ŸÅŸä ÿ®Ÿäÿ¶ÿ© ÿ≠ŸÇŸäŸÇŸäÿ©. --- ## **1. ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿµÿßÿØŸÇÿ© OAuth (Google ŸàFacebook)** ### **Backend - ÿ•ÿπÿØÿßÿØ OAuth ŸÖÿπ Passport.js:** #### **ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑÿ≠ÿ≤ŸÖ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©:** ```bash npm install ÿ¨Ÿàÿßÿ≤ ÿ≥ŸÅÿ± ÿ¨Ÿàÿßÿ≤ ÿßŸÑÿ≥ŸÅÿ±-google-oauth20 ÿ¨Ÿàÿßÿ≤ ÿßŸÑÿ≥ŸÅÿ± -facebook ``` #### ** ÿ™ŸáŸäÿ¶ÿ© Passport.js:** ```javascript // backend/config/passport.js const ÿ¨Ÿàÿßÿ≤ ÿßŸÑÿ≥ŸÅÿ± = require('passport'); const GoogleStrategy = require('passport-google-oauth20').Strategy; const FacebookStrategy = require('passport-facebook').Strategy; Passport.use(new GoogleStrategy({clientID: 'YOUR_GOOGLE_CLIENT_ID',clientSecret: 'YOUR_GOOGLE_CLIENT_SECRET', callbackURL: '/auth/google/callback' }, (accessToken, RefreshToken, Profile, Done) => { // ŸÖŸÜÿ∑ŸÇÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÜÿØ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä ŸÖŸÜ Google return Done(null, Profile })); Passport.use(new FacebookStrategy({clientID: 'YOUR_FACEBOOK_CLIENT_ID',clientSecret: 'YOUR_FACEBOOK_CLIENT_SECRET', callbackURL: '/auth/facebook/callback' }, (accessToken, RefreshToken, Profile, Done) => { // ŸÖŸÜÿ∑ŸÇÿ© ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÜÿØ ÿßÿ≥ÿ™ŸÑÿßŸÖ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä ŸÖŸÜ Facebook return Done(null, Profile })); Passport.serializeUser((user, Done) => { Done(null, user); }); passwd.deserializeUser((user, done) => { done(null, user); }); ``` #### ** ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿ≥ÿßÿ±ÿßÿ™ OAuth:** ```javascript // backend/routes/authRoutes.js ÿ´ÿßÿ®ÿ™ express = require('express'); ÿ´ÿßÿ®ÿ™ passport = require('passport'); ÿ´ÿßÿ®ÿ™ router = express.Router(); // Google OAuth router.get('/google', passware.authenticate('google', { ÿßŸÑŸÜÿ∑ÿßŸÇ: ['ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä'ÿå 'ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä'] })); router.get('/google/callback'ÿå passwd.authenticate('google'ÿå { ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸá ÿßŸÑŸÜÿßÿ¨ÿ≠ÿ©: '/dashboard'ÿå ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸá ÿßŸÑŸÅÿßÿ¥ŸÑÿ©: '/login' } )); // ÿ¨Ÿáÿßÿ≤ ÿ™Ÿàÿ¨ŸäŸá OAuth ÿßŸÑÿÆÿßÿµ ÿ®ŸÅŸäÿ≥ÿ®ŸàŸÉ.get('/facebook', passwd.authenticate('facebook')); router.get('/facebook/callback', pass.authenticate('facebook', { successRedirect: '/dashboard', failureRedirect: '/login' })); module.exports = router; ``` #### **ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ:** ```javascript // backend/index.js const express = require('express'); const session = require('express-session'); const passe = require('passport'); ÿ™ÿ™ÿ∑ŸÑÿ® ('./config/passport'); const authRoutes = require('./routes/authRoutes'); const app = express(); app.use(session({ secret: 'your_secret_key', ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ≠ŸÅÿ∏: false, ÿ≠ŸÅÿ∏ ÿ∫Ÿäÿ± ŸÖŸáŸäÿ£ : false })); app.use(passport.initialize()); app.use(passport.session()); app.use('/auth', authRoutes); const PORT = 3000; app.listen(PORT, () => console.log(`ÿÆÿßÿØŸÖ ŸäÿπŸÖŸÑ ÿπŸÑŸâ http://localhost:${ŸÖŸäŸÜÿßÿ°}`)); ``` --- ### **Frontend - ÿ•ÿ∂ÿßŸÅÿ© ÿ£ÿ≤ÿ±ÿßÿ± OAuth:** ```javascript // frontend/pages/Login.js Ÿàÿ∏ŸäŸÅÿ© ÿßŸÑÿ™ÿµÿØŸäÿ± ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© Login() { return ( <div> <h1>Login</ h1> <a href="/auth/google"> <button>ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Google</button> </a> <a href="/auth/facebook"> <button>ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Facebook</button> </ ÿ£> </div> ); } ``` --- ## **2. ŸÜÿ¥ÿ± ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿπŸÑŸâ Vercel ÿ£Ÿà AWS** ### **ŸÜÿ¥ÿ± ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿπŸÑŸâ Vercel:** #### **ÿßŸÑÿÆÿ∑Ÿàÿßÿ™:** 1. ŸÇŸÖ ÿ®ÿ™ÿ´ÿ®Ÿäÿ™ [Vercel CLI](https://vercel.com/cli) ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖÿ´ÿ®ÿ™Ÿãÿß: ``bash npm install -g vercel``` 2. ÿßŸÜÿ™ŸÇŸÑ ÿ•ŸÑŸâ ÿØŸÑŸäŸÑ ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ: ```b




ÿßŸÜÿ™ ŸÇŸÑÿ™:
ŸÜÿπŸÖ
ŸÇÿßŸÑ ChatGPT:

ŸÑÿß! ÿ≥ŸÜŸÉŸÖŸÑ ÿßŸÑÿ¢ŸÜ ÿ•ÿ∂ÿßŸÅÿ© **ÿ¥ŸáÿßÿØÿ© SSL** ŸÑÿ™ÿ£ŸÖŸäŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸäŸÜ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸàÿßŸÑÿÆÿßÿØŸÖ. ÿ≥ÿ£ÿ¥ÿ±ÿ≠ ÿ£Ÿäÿ∂Ÿãÿß ŸÉŸäŸÅŸäÿ© **ÿ•ÿπÿØÿßÿØ ŸÖÿ±ÿßŸÇÿ®ÿ© ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ AWS CloudWatch** Ÿàÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ£ÿØÿßÿ° ŸàÿßŸÑÿ•ŸÜÿ∞ÿßÿ±ÿßÿ™ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÅÿπŸÑŸä. --- ## **1. ÿ•ÿπÿØÿßÿØ ÿ™ÿ£ŸÖŸäŸÜ SSL ŸÑŸÑÿ™ÿ∑ÿ®ŸäŸÇ** ### **ÿ£. ÿ•ŸÜÿ¥ÿßÿ° ÿ¥ŸáÿßÿØÿ© SSL ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Let's Encrypt (ÿπŸÑŸâ ÿÆÿßÿØŸÖ Linux):** #### **ÿßŸÑÿÆÿ∑Ÿàÿßÿ™:** 1. **ÿ™ÿ´ÿ®Ÿäÿ™ Certbot:** ÿ•ÿ∞ÿß ŸÉŸÜÿ™ ÿ™ÿ≥ÿ™ÿÆÿØŸÖ ÿÆÿßÿØŸÖ Ubuntuÿå ŸÜŸÅÿ∞ ÿßŸÑÿ£ŸÖÿ± ÿßŸÑÿ™ÿßŸÑŸä: ```bash sudo apt update Sudo apt install certbot python3-certbot-nginx ``` 2. **ÿ™





